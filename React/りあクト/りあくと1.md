# りあくと ①言語・環境編


## React
- React は UI を「宣言的」に構築するために作られたプロダクトであり、その実現のために関数型プログラミングが多く用いられます。宣言的であるとはどういうことかや、関数型プログラミングについて基本的なことを知っていなければ、「React らしい」コードを書くことは不可能です。（関数型プログラミングでは式の組み合わせでロジックを作っていくので、関数型言語では多くの構文が式になってる。）
関数型プログラミングでは、先行する式の評価を後続の式に適用し、それをつなげていって最終的な評価値に到る式のツリーを記述することでプログラムを組み立てていく。そして式というのはほとんどの場合、値を演算するか関数を呼びだすか、またはそれらの組み合わせでしかない。
なので、y = f(x) + w のような数学的な式を多用するスタイルがより好まれる。文でなく式で書きたいケースというのは開発の現場ではよくある。
※

- React は最初から必要なものがひととおりそろっているフルスタックのフレームワークではなく、それなりの規模のアプリケーションを開発するためにはサードパーティのライブラリをいくつも組み合わせる必要があります。

- React で作られるアプリケーションは、すべて『コンポーネント（Component）』の組み合わせで構成される。
    - 命名規則として、コンポーネント名は必ず大文字で始まるパスカルケース(アッパーキャメルケース)になってる(ちなみにインポート時のファイル拡張子は省略可能)
    - React ではコンポーネントの実装は、関数またはクラスで定義することになってる。

- Vue や Angular といったフロントエンドの他の競合と比べても自由度が高い。
    - 色んなやり方が乱立してしまう


## 対象読者
- フレームワークではなく UI ライブラリを自称していることもあり、JavaScript の力をフルに活用するようになっていて、JavaScript 初心者には全く歯が立ちません。公式ドキュメントでさえ、JavaScript と同時に習得は難しいので先にそちらを学んできてくださいと断っているほどです。

- 思想・歴史を知ることは、その技術を使ってシステムを正しく設計し、可読性とメンテナンス性および拡張性を担保したコードを書くための近道です。


## 環境構築
1. Node.js をインストールする
    - Node.js のインストールのやりかたは色々あって Mac なら Homebrew、Windows なら winget といったパッケージ管理ツールのリストに Node.js があるので、それらを使って入れるのが簡単で手っ取り早い。でも私たちはアプリケーション開発のプロなので、プロジェクトごとに異なるバージョンの環境を共存させるのが必要になることがある
    1. Homebrewをインストール

    1. バージョンマネージャをインストール
        - $ brew install asdf（asdf ではプラグインとして管理できる言語環境が 500 近くもあり、それぞれの最新バージョンへの追随も早い。）
            - asdf plugin list …… インストール済みのプラグインの一覧を表示
            - asdf plugin list all …… インストール可能なプラグインの一覧を表示
            - asdf list <PLUGIN_NAME> …… プラグインのインストール済みのバージョンの一覧を表示
            - asdf list all <PLUGIN_NAME> …… プラグインのインストール可能なバージョンの一覧を表示
            - asdf plugin add <PLUGIN_NAME> …… プラグインをインストール
            - asdf plugin update <PLUGIN_NAME> …… プラグインをアップデート
            - asdf plugin remove <PLUGIN_NAME> …… プラグインを削除
            - asdf install <PLUGIN_NAME> <VERSION> …… プラグインパッケージの任意のバージョンをインストール。バージョンの代わりに latest を指定すると最新版になる
            - asdf uninstall <PLUGIN_NAME> <VERSION> …… プラグインパッケージの任意のバージョンをアンインストール
            - asdf global <PLUGIN_NAME> <VERSION> …… グローバルに使うパッケージのバージョンを設定
            - ・asdf local <PLUGIN_NAME> <VERSION> …… そのディレクトリ配下で使うパッケージのバージョンを設定
        - 現在メジャーなのは古くからある nvm、新興では fnm や Volta あたり（Node.js を単体でしか管理できない）

    1. ホームディレクトリに.default-npm-packages というファイルを作って次の内容を書き込
        -   yarn
            typescript
            ts-node
            typesync
            npm-check-updates
        ※「Node の任意のバージョンをインストールしたとき、デフォルトでいっしょにインストールされる npmパッケージを登録しておく

    1. Node.js をインストールする
        -   $ asdf plugin add nodejs
            $ asdf install nodejs latest
            $ asdf global nodejs latest　　グローバルに使う Node のバージョンを指定
        -   node --version　でインストールの確認

1.  VS Code 拡張リスト
    - ESLint （ dbaeumer.vscode-eslint ）… JavaScript の静的コード解析ツール ESLint を VS Code に統合する
    - stylelint （ stylelint.vscode-stylelint ）… CSS 用のリンター stylelint を VS Code に統合する
    - Prettier （ esbenp.prettier-vscode ）… コード自動整形ツール Prettier を VS Code に統合する
    - Visual Studio IntelliCode （ VisualStudioExptTeam.vscodeintellicode ）… AI 支援によりコード補完の精度を向上させる
    - Path Intellisense （ christian-kohler.path-intellisense ）… インポートのパスを自動補完してくれる
    - indent-rainbow （ oderwat.indent-rainbow ）… インデントの階層を色分けして見やすくしてくれる
    - Auto Rename Tag （ formulahendry.auto-rename-tag ）… HTML/XMLの開きタグ閉じタグどちらかの要素名を変更すると、対応するタグも同期してくれる
    - vscode-icons （ vscode-icons-team.vscode-icons ）… 左ペインの Explorer のファイルアイコンをバリエーション豊かにしてくれる
    - JSON to TS （ MariusAlchimavicius.json-to-ts ）… JSON オブジェクトを TypeScript のインターフェースに変換してくれる
    - Import Cost （ wix.vscode-import-cost ）… モジュールをインポートしている文の横に、算出したバンドルサイズを表示してくれる
    - Git History （ donjayamanne.githistory ）… Git のコミット履歴を見やすく表示してくれる
    - Remote - WSL （ ms-vscode-remote.remote-wsl ）… Windows 環境から WSL のファイルシステム上にあるプロジェクトを開けるようにする
    - Live Share （ MS-vsliveshare.vsliveshare ）… 複数人によるリアルタイムのコーディングコラボレーションを実現する

1. Vite でプロジェクトを作成する
    - $ yarn create vite hello-world --template=react-ts　「hello-world がプロジェクトの名前で、その名前のディレクトリ配下に必要なファイルが置かれる
    -   cd hello-world
        yarn
            - 正確には yarn install。このコマンドはpackage.json に記述されている依存パッケージを node_modules/ 配下にインストールして、さらにインストールされたパッケージのバージョン情報を、その依存関係も含めて yarn.lock というファイルに出力するもの
            - node_modules/　アプリケーションに必要な npm パッケージの実体がそこに置かれる
            - yarn.lock　それぞれ相互に特定のバージョンに依存してるので、ちょっとバージョンを変更しただけでアプリケーションが動かなくなることがある。だからいつ誰がインストールしてもすべてのパッケージで完全に同じバージョンがインストールされるよう、いったんインストールしたパッケージの依存情報を保存しておくためのファイル
            -  Git のリポジトリに node_modules/ は入れないけど、yarn.lock は必ず入れておくようにする
        yarn dev
            - デフォルトだと HTTP サーバが 5173 番ポートで立ち上がる。別のポート番号にしたい場合は yarn dev--port=3000 のように指定してあげるといい
    - プロジェクトファイルの説明（React のアプリケーションが必ずしもこのファイル構成になるわけじゃない）
        - src/　アプリケーションのソースコードを置く
        - node_modules/　アプリケーションに必要な npm パッケージが保存されている
        - public/　公開用のアセットファイルを置く
        - package.json　インストールするパッケージの情報などが書かれた設定ファイル
        - yarn.lock　インストールしたパッケージの依存情報が保存されたファイル
        - tsconfig.json　TypeScript をコンパイルするための設定ファイル
        - tsconfig.node.json　Vite の設定を TypeScript で書くための tsconfig.json
        - vite.config.ts　Vite の設定ファイル
        - gitignore　Git リポジトリに含めないものリスト




### 役割まとめ
- Vite　プロジェクト作成ツール
- Yarn　パッケージ管理
- TypeScript　開発言語


### 不明ワード
- MVC　Model-View-Controller。UI を持つアプリケーションソフトウェアを実装するためのデザインパターンで、システムを機能別に Model（モデル）、View（ビュー）、Controller（コントローラ）の3つの要素に分割して設計する。データを保持する Model があって、View のテンプレートに Model が出力する値を埋め込んでいくやり方。

- MVVM　「Model － View － ViewModel からなる構成、

- Node.js　JavaScript を Ruby や Python と同じように秋谷さんの PC のターミナル上で実行できる環境を提供するソフトウェア
    主なNode を使うことで開発時に可能になること
    - パフォーマンス最適化のために JavaScript や CSS ファイルを少数のファイルにまとめる（＝バンドル）
    - 新しいバージョンの JavaScript や AltJS ・12 のコードを古いバージョンの JavaScript コンパイルして、古いブラウザでも動作可能にする
    - 開発環境においてブラウザにローカルファイルを直接読み込ませるのではなく、ローカルに開発用のアプリケーションサーバを稼働させることで、動作を検証しやすくし開発効率を高める
    - テストツールを用いてユニットテストや E2E テスト ・13 を記述・実行する
    - ソースコードの静的解析や自動整形を行う

- npm　それなりの規模のアプリケーションを作ろうとすると、サードパーティのライブラリをいくつも読み込んでくる必要があって、それらは相互に特定のバージョンで依存しあってたりする。それらをただのスクリプトファイルとして読み込むなら、秋谷さんはライブラリ間の依存関係手で解決して、ライブラリに新しいバージョンが出てアップデートするときにもそれをいちいち最初からやり直す必要がある。

- windowsかmacか　ただ Node を Windowsのネイティブ環境で動かすのはあんまりおすすめできない。Web アプリケーションサーバは UNIX 環境で動作させることが圧倒的に多いので、開発環境もそれに合わせたほうがトラブルが少ないから。

- REPL　 「Read-Eval-Print Loop」の略で、対話型の実行環境を意味する。

- VS Code　TypeScript と相性がよくて型の整合性チェックやNull 安全性のチェックとかをコーディング中に自動でやってくれる

- JSX　 JavaScript の構文を拡張したもので、言ってみれば非公式な JavaScript の一方言みたいなもの

- HMR（Hot Module Replacement）　ソースコードを変更・保存するとアプリケーションに即座に反映される

- 変数　あくまでconstを第一選択肢。どうしても再代入が必要な時はlet

- 関数　
    - 式　変数に代入できる（評価された後に値として存在する）
    - 文　変数に代入できない（何らかの手続きを処理系に命令するもの）
        - デメリット　関数宣言文による定義のほうは var による変数宣言と同じ問題を抱えてる（再宣言ができてしまう、宣言の巻き上げ）
            ？関数は宣言文より関数式で定義したほうがいい？
                開発者のコミュニティでは宣言文で定義しているほうが圧倒的に多数派。関数式による定義はあまり直感的じゃなく、書き方もまどろっこしく感じられる。また実際の開発の場面では、関数宣言の巻き上げや再宣言は便利に使えることも多い。
        - 注意点　
            - 関数の定義に Funtion コンストラクタによるインスタンス生成は、文字列を直接 JavaScriptのコードとして評価する必要があったり、作られた関数が常にグローバルスコープで実行されるという危険性があって推奨されてない
            - 関数式って名前付きで定義できる。名前をつけたところで変数に代入してしまえば元の名前は意味を持たないので、つける意味がない
            - 関数式による関数の定義っていうのは実際のところ、無名関数をいったん生成した上でそれを変数に代入することによってメモリ上に残してるってこと
            - React によるアプリケーション開発の場面ではアロー関数式を使うのが個人的にはいい

- JavaScript は他の言語と比べて、配列やオブジェクトの表現力がかなり高い
    - プロパティ名のショートハンド　React の開発でもよく使われてる
    - 分割代入　右辺と同型の配列やオブジェクトを用意することで、左辺側でそれに対応する値を変数に代入できる（よく使われてる）
    - スプレッド構文　（React でも多用される構文）
        - 挿入する位置がどこでもいいわけじゃない。配列では展開した場所に順番が依存してるし、オブジェクトでは展開した後に同じキーのプロパティがあると値が上書きされる。完成形を見据えてどの位置でその配列やオブジェクトを展開するべきかはよく考えないといけない
    - シャローコピー（Shallow Copy）

- ショートサーキット評価（Short-Circuit Evaluation 短絡評価）　
    - && や ||、! といった論理演算子が左から右に評価される性質を利用して、右項の評価を左項の評価に委ねる記法
    - React コンポーネントの記述でもこの書き方が頻繁に利用されてる

- Nullish Coalescing と Optional Chaining
    - ?? を並べてる部分が Nullish Coalescing
        - OR 演算子 || に似てるんだけど、異なるのは左項が null または undefined のときだけ右項が評価される
        -  0 や '' の空文字といった falsy な値はそのまま評価される
        - || によるショートサーキット評価より明示的な nullish coalescing のほうが望ましい
        - nullish coalescing が使えるときは、OR 演算子によるショートサーキット評価じゃなくできるだけこっちを使いましょう
    - ?. でつないでる部分が Optional Chaining
        - チェーン内の各参照が正しいかどうかを明示的に確認せずにアクセスしていくことができる
        - 途中のプロパティが存在していなかったら、そこで式が短絡されてundefined を返してくる

- JavaScript の鬼門、this を理解する
    - 初期設計をミスったせいで、安全性を担保するためには言語としての一貫性を犠牲にするしかなかった
    - 基本的に JavaScript の this はその実行コンテキストであるオブジェクトへの参照（クラスメソッドはおろか通常の関数の中、さらにはトップレベルのスコープでいきなり参照することもできる）
    ※JavaScript におけるトップレベルの実行環境は必ず何らかのグローバルオブジェクト（トップレベルでの this の参照は普通やらない）

    - JavaScript の関数も任意の this を設定できる
        - call()　第 1 引数で渡したオブジェクトが this になり、第 2 引数以降がその関数の引数として渡された上で実行される
        - bind()　その関数に this になるべきオブジェクトが設定された新しい関数を作るためのメソッド
        ※明示的な引数として this を渡さない JavaScript でも関数がメソッドとして再利用できる
        ※アロー関数は call() や bind() で任意のオブジェクトを this に設定できなくなってる

    - this の中身 4 つのパターン
        - new 演算子をつけて呼び出されたとき： 新規生成されるオブジェクト
        - メソッドとして実行されたとき： その所属するオブジェクト
        - 1・2 以外の関数【非 Strict モード】： グローバルオブジェクト
        - 1・2 以外の関数【Strict モード】：undefined

    - 2 つを原則として徹底する（解決法は常にシンプルであるべき）
        - this はクラス構文内でしか使わない
        - クラス内では、コンストラクタ以外のメソッドおよびその内部関数の定義はアロー関数式で行う

- JavaScript にはコードから他のファイルを読み込むためのしくみ、つまりモジュールシステムというものがなかった
    - ファイルを分割するならそれは ＜script src="..."＞ タグでベタなスクリプトファイルとして読み込むしかなく、そして読み込んだものはすべてフラットにグローバル空間へ展開されてしまってた。この状況を大きく変えたのは 2009 年の Node.js の登場だった。サーバサイド言語としての JavaScript の体裁を整えるために CommonJS という標準 API 仕様を定めるプロジェクトを立ち上げた。
    - ES2015 の大変革の中に、モジュールシステムも盛り込まれていた。その名も ES Modules、略して ESM
    - モジュールとして読み込まれたコードは
        - import / export が使える
        - 常に strict モードが適用される
        - トップレベルで定義された変数がグローバルスコープに展開されることはなく、そのモジュール内のローカル変数になる
    - ES Modules でインポート／エクスポート
        - package.json に"type": "module",というオプションの記述が必要
            - これでそのディレクトリの下層に置かれた拡張子 .js または .mjs の JavaScript ファイルが ES Modulesとしてロードされるようになる

- 関数型プログラミング　
    - 数学の関数は、与えた引数が同じなら返る値は常に一定でしょう？ そういう同じ入力に対して同じ作用と同じ出力が保証されていることを参照透過性という。関数型プログラミングとは、参照透過的な関数を組み合わせることで解決するべき問題に対処していく宣言型のプログラミングのスタイルのこと。
    [1, 2,3].map((n) => n * 2)　//map メソッドに引数としてアロー関数式で記述された無名関数を渡してた
    ↓
    const double = (n) => n * 2;
    [1, 2, 3].map(double);　//配列の map メソッドに引数として double という関数を渡してる
    - 特徴
        - 名前を持たないその場限りの関数（無名関数）を定義できる
        - 変数やデータ構造の値として関数を設定できる
        - 関数に引数として関数を渡したり、その戻り値に関数を設定できる（高階関数）
        - 関数に特定の引数を固定した新しい関数を作ることができる（部分適用）
        - 複数の高階関数を合成してひとつの関数にできる（関数合成）

    - 高階関数（Higher Order Function）
        - 引数に関数を取ったり、戻り値として関数を返したりする関数のこと（Array オブジェクトのプロトタイプメソッドである map() や filter() がそう）
        - 『コールバック』というのは、この引数として渡される関数のこと
        1. 例
        ```
        const greeter = (target) => {
            const sayHello = () => {
                console.log(`Hi, ${target}!`);
            };
            return sayHello;
        };
        const greet = greeter('Step Jun');
        greet(); // Hi, Step Jun!
        ```
        - ここで注目するべきは、返してるのが sayHello の実行結果じゃなくて関数そのものだということ。return sayHello() と記述してしまうとその場で関数を実行して、その結果の undefined を返してしまうので気をつけて
        1. 関数型プログラミングでは不要な代入は避ける
        ```
        const greeter = (target) => {
            return () => {
                console.log(`Hi, ${target}!`);　// その場でただ return するだけなので、わざわざその関数に sayHello という名前をつける必要はありません
            };
        }
        ```
        1. そしてアロー関数式では、内容が return 文だけだった場合はそのブロックごと表記を省略できたよね。だから最終的にはこうなる
        ```
        const greeter = (target) => () => console.log(`Hi, ${target}!)`;
        ```

        - カリー化（複数の引数を取る関数を、より少ない引数を取る関数に分割して入れ子にすること）
            - 引数が『元の関数の最初の引数』で戻り値が『引数として元の関数の残りの引数を取り、それを使って結果を返す関数』である高階関数にすることを『カリー化』と呼ぶ
            ```
            // カリー化前
            {
                const multiply = (n, m) => n * m;　// multiply は引数 n と m を取り、その積を返すだけの関数
                console.log(multiply(2, 4)); // 8
            }
            // カリー化
            {
                const withMultiple = (n) => {　// withMultiple は n を引数に取った上で『m を引数に取り n との積を返す関数』を返す関数
                    return (m) => n * m;
                };
                console.log(withMultiple(2)(4)); // 8　withMultiple の実行時にかっこが 2 つ並んでるのは、「withMultiple(n) 自体が『m を引数に取って m * n を返す関数』だから、それを関数として実行するためにもうひとつかっこが必要なわけ
            }
            // アロー関数式でカリー化
            {
                const withMultiple = (n) => (m) => n * m;
                console.log(withMultiple(2)(4)); // 8
            }
        ```



- 『命令型プログラミング（Imperative Programming）』と『宣言型プログラミング（DeclarativeProgramming）』
    - 命令型
        - 最終的な出力を得るために状態を変化させる連続した命令文によって記述されるプログラミングスタイルのことをいう。ステップ順にその指示にしたがっていけば、お目当ての料理ができあがるレシピと似てるね。目の前のことだけ考えてひとつずつ積み上げていけばいいので、プログラミング初心者にとっても敷居が低い
        - 『手続き型プログラミング（Procedural Programming）
            - 手続きというのは一連の命令文の組み合わせをまとめた、サブルーチンや関数と呼ばれるもの。主にグローバル変数としてまとめたデータを、複数の手続きを経て最終結果を得るプログラミングスタイル（COBOL や BASIC、Pascal、C、Go）
            - オブジェクト指向と手続き型、両者の性質を兼ね備えた言語
                - 現代ではもっともメジャーになってるといえる。Java、C++、C#、Python、Ruby とかが
    - 宣言型
        - 宣言型プログラミングでは出力を得る方法ではなく、出力の性質・あるべき状態を文字通り宣言することでプログラムを構成する
            - SQL がもっとも有名な宣言型プログラミング言語

    ※ オブジェクト指向プログラミングは、命令型か宣言型かという分類からは独立したパラダイム
    ※ 難しく感じるのは、出力のあるべき状態を数学的に定義する手法になじみがないだけ

    具体的なコード（1 から 100 までの範囲における 8の倍数を格納した配列を作る）
    // 手続き型プログラミング（文）
    ```
    {
        const octuples = [];
        for (let n = 1; n < 101; n += 1) {
            if (n % 8 === 0) {
                octuples.push(n);
            }
        }
        console.log(octuples);
    }
    // 関数型プログラミング（式）
    {
        const range = (start, end) => [...Array(end - start)].map((_, n) => n + start);
        const octuples = range(1, 101).filter((n) => n % 8 === 0);
        console.log(octuples);
    }
    ```

    - 2 つのスタイルの特徴
        - 可変性（Mutablity）と不変性（Immutablity）
            - 関数型で書いたほうは変数のひとつたりとも再代入や破壊的変更がなされてない
            - 手続き型のほうは octuples に 12 回の破壊的変更、n に 100 回の再代入がある
            ※ 関数型プログラミングでは、代入自体もできるだけ控える傾向にある。メソッドチェーンや演算子で式をつないでいき、関数もその場限りのものならできるだけ無名関数のまま使う
            - イメージ
                - 関数型プログラミングは、最初から完成形を見据えた上で大雑把なところから絞り込んでいく形になる（ゲームスタートの時点でマップの対岸にラスボスである竜王の城がすでに見えてるドラクエⅠみたいなイメージ）
                - 手続き型ではボトムアップ的に積み上げていって最終成果物を完成させる

    - コレクションの反復処理　（関数型プログラミングへの最初の入り口はコレクションの反復処理）
        - 配列の反復処理
            - 
            ```
            const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
            console.log(
                arr.map((n) => n * 2), // [ 2, 4, 6, 8, 10, 12, 14, 16, 18 ]
                arr.filter((n) => n % 3 === 0), // [ 3, 6, 9 ]
                arr.find((n) => n > 4), // 5
                arr.findIndex((n) => n > 4), // 4
                arr.every((n) => n !== 0), // true
                arr.some((n) => n >= 10), // false
            );
            ```

            - map()       …… 対象の配列の要素ひとつひとつを任意に加工した新しい配列を返す
            - filter()    …… 与えた条件に適合する要素だけを抽出した新しい配列を返す
            - find()      …… 与えた条件に適合した最初の要素を返す。見つからなかった場合は undefind を返す
            - findIndex() …… 与えた条件に適合した最初の要素のインデックスを返す。見つからなかった場合は -1を返す
            - every()     ……「与えた条件をすべての要素が満たすか」を真偽値で返す
            - some()      ……「与えた条件を満たす要素がひとつでもあるか」を真偽値で返す

            ```
            const arr = [1, 2, 3, 4, 5];
            console.log(
                arr.reduce((n, m) => n + m), // 15
                arr.sort((n, m) => n > m ? -1 : 1), // [ 5, 4, 3, 2, 1 ]
            );
            ```

            - reduce() …… 引数に何が入ってくるかというのをおぼえておくといいよ。この第 2 引数 m には arr の各要素の値が順番に入ってくるんだけど、第 1 引数 n には前回の関数の実行結果が入ってくる。そうして最終的にreduce() が返すのは最後に実行された値だけ。
                - 1 回めの実行： m = 1 、前回の実行がないので、結果は 1 がそのまま返る
                - 2 回めの実行： m = 2 、前回の実行結果により n = 1 、結果は 1 + 2 = 3 が返る
                - 3 回めの実行： m = 3 、前回の実行結果により n = 3 、結果は 3 + 3 = 6 が返る
                - 4 回めの実行： m = 4 、前回の実行結果により n = 6 、結果は 6 + 4 = 10 が返る
                - 5 回めの実行： m = 5 、前回の実行結果により n = 10 、結果は 10 + 5 = 15 が返る

            - sort()   …… 読んでそのとおりのソート（並べ替え）を行うメソッドで引数は省略することもできる。ただその場合は、各要素が暗黙のうちに文字列に変換され Unicode の文字コード順にソートされるというよくわからない仕様なので、極力省略しないほうがいい。省略しない場合の引数には、既定の『比較関数』というものを渡すようになってる。その比較関数が守るべきルールは次の 3 つ
                - 第 1 引数が第 2 引数より優先度が高い（前に並べる）場合、 0 未満の数値を返す
                - 第 1 引数が第 2 引数より優先度が低い（後に並べる）場合、 0 より大きい数値を返す
                - 第 1 引数と第 2 引数の優先度が同じ（ソートの必要がない）場合、 0 を返す（※省略可）
            - JavaScript では Array オブジェクトの sort() は破壊的メソッドなので、他の処理と組み合わせる際には気をつける必要がある
                - JavaScript って破壊的メソッドと非破壊的メソッドが混在してて見分ける方法がない = これはもう丸暗記するしかない
                - 破壊的メソッド
                    - 並べ替えを行う sort()
                    - 配列の要素を反転させる reverse()

                    - ただ配列に要素を追加し戻り値として新しい配列の長さを返すpush() や unshift()
                    - 配列から要素を取り除いてその値を返す pop() や shift()
                        - ↑上二つは返す値が更新した配列じゃないので関数型プログラミングの文脈ではまず出番がないはず。
            - ※配列の反復処理には値を返さない構文もある。よく使われるのは Array.prototype.forEach() メソッドと for...of 文
                - そもそも値を返さないこれらを使う目的って、主にその中で外部のミュータブルな変数を書き換えるといった副作用を起こすことだろうから、関数型プログラミングの文脈では往々にしてロジックの組み方をまちがえてるケースが多い。ほとんどの処理は map() や find() といった最初に挙げた値を返すメソッドでの組み合わせで十分なはずなので、どうしても他の方法が見つからなかった場合のみ forEach()を例外的に使うという感じ
            - Array で紹介しておきたいのが includes() というメソッド
                - 「includes() は『指定した値の要素がひとつでも含まれているか』を真偽値で返す。条件式に活用できるので便利
            - JavaScript で任意の回数だけ繰り返し処理をしたい場合、外部のライブラリを使わずに手っ取り早く書く方法
                - Array オブジェクトは keys() メソッドを備えていて、イテレータ 143 という今となってはあまり使われない反復処理のしくみのためのオブジェクトを返す。これを展開して配列に戻すと要素のインデックスが取り出せるので、こういう使い方ができるのね。
                ```
                > [...Array(3).keys()]
                [ 0, 1, 2 ]
                > [...Array(3).keys()].map((n) => { console.log(`${n + 1} times`); });
                1 times
                2 times
                3 times
                ```

        - オブジェクトの反復処理
            - 狭義のオブジェクト 144、つまり標準組み込みオブジェクト Object を直接継承するオブジェクトの反復処理。
            - 巷では for...in 文 145 が使ったコードをよく見かけるけど、配列のときの for...of と同じ理由で勧められない。Object 自身が持つメソッドを使っていったん配列を形成する方法が Airbnb のスタイルガイドでは推奨されてる
